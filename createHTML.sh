gbcount=0

##
## Create Cover Page
##
function makeIntroPage  ( ){
	echo "Creating Intro Page"
	title="$1"
	coverimage=$2
	link=$3
	htmlout=$4
	zipireport=$5
	
	echo -e "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">
<html>
	<head>
	</head>
	<body>
		<br/>
		<br/>
		<center>
		<b><font size=\"15\"> iReport: ${title} </font></b><br/>
		<br/>
		<br/>
		<a href=\"$link\">  Click image to view report	</a> <br/><br/>
		<a href=\"$link\"> <img src="$coverimage" width=\"50%\" alt=\"loading image..\"/> </a><br/><br/>		
		<a href=\"$zipireport\">  Click here to download a copy of this iReport </a> <br/><br/>
		</center>
	</body>
</html>" > $htmlout

}

##
## Decompress archive fiels
##  -> will detect archive formats: zip, tar, gzip, tar.gz, bzip2
##  -> input: path to archive
##  -> files will be located in ${galaxypath}/archive_${fname}/
##
function decompressArchive (){
	archive=$1
	
	fname=`basename ${archive}`
	fname=${fname%.dat}
	ftype=`file $archive`
	
	if [[ ! -d ${galaxypath}/archive_${fname}/ ]]
	then
		mkdir ${galaxypath}/archive_${fname}/
		
		#echo "archive type: `file $archive`"
		# decompress archive
		if [[ $ftype == *Zip* ]]
		then
		#echo "detected zip file"
			cp $archive ${galaxypath}/archive_${fname}/${fname}.zip
			wd=`pwd`
			cd ${galaxypath}/archive_${fname}/
			unzip -q ${fname}.zip
			rm ${fname}.zip
			cd $wd
		fi
		if [[ $ftype == *tar* ]]
		then
			cp $archive ${galaxypath}/archive_${fname}/${fname}.tar
			wd=`pwd`
			cd ${galaxypath}/archive_${fname}/
			tar xf ${fname}.tar
			rm ${fname}.tar
			cd $wd
		fi
		if [[ $ftype == *gzip* ]]
		then
			cp $archive ${galaxypath}/archive_${fname}/${fname}.gz
			gunzip ${galaxypath}/archive_${fname}/${fname}.gz
			#ls ${galaxypath}/archive_${fname}/
			
			# check for tar.gz
			ftype=`file ${galaxypath}/archive_${fname}/${fname}`
			if [[ $ftype == *tar* ]]
			then
				# turns out it was tar.gz
				rm -Rf ${galaxypath}/archive_${fname}/*
				ls ${galaxypath}/archive_${fname}/
				cp $archive ${galaxypath}/archive_${fname}/${fname}.tar.gz
				
				wd=`pwd`
				cd ${galaxypath}/archive_${fname}/
				tar xzf ${fname}.tar.gz 
				cd $wd
			fi
			wait
			rm -f ${galaxypath}/archive_${fname}/*.tar
			rm -f ${galaxypath}/archive_${fname}/*.tar.gz
		fi
		if [[ $ftype == *bzip2* ]]
		then
			cp $archive ${galaxypath}/archive_${fname}/${fname}.gz
			gunzip2 ${galaxypath}/archive_${fname}/${fname}.gz
		fi
	fi
}

##
## Create HTML content for the tabs specified by user
##
function makeTabContent ( ){
	tab=$1			# name of current tab
	itemslist=$2	# list of all items
	tracklist=$3	# genome browser tracks info
	contentline=""  # HTML code for tab
	imgcount=0		# keep track of the number of images on the current tab
	iframecount=0
	
	for item in $itemslist
	do
		## Parse items lists
		item=${item/::/:emptycol:}
		declare -a myarr=(`echo $item |sed 's/:/ /g'`)
		
		## Create the tab contents HTML code
		if [ ${myarr[0]} == $tab ]
		then
			
			##
			##  Text Field
			##			
			if [ ${myarr[1]} == "text" ]
			then
				text=${myarr[2]}
				md=${myarr[4]}
				
				# if markdown, convert to html
				if [ $md == "Y" ]
				then
					## resubstitute sanitized charachters
					text=${text//==space==/ }
					text=${text//==colon==/:}
					text=${text//==comma==/,}
					
					text=${text//==braceopen==/(}
					text=${text//==braceclose==/)}
					text=${text//==cbraceopen==/{}
					text=${text//==cbraceclose==/&#125;}
					
					text=${text//==slash==/\/}
					text=${text//==lt==/<}
					text=${text//==gt==/>}
					text=${text//==apos==/\'}
					text=${text//==quote==/\"}
					text=${text//==backtick==/\`}
					text=${text//==dollar==/$}
					text=${text//==bar==/|}
					text=${text//&&/&}
					text=${text//\\n/\\n}
					text=${text//\\t/\\t}
					text=${text//\&r\&n/\\n}
					text=${text//\&r/\\n}
					text=${text//\&n/\\n}
					text=${text//\&c/:}

						
					## convert markdown in textfield to html
					echo -e "$text" > mytext.md
					
					if [ -z `type -p pandoc` ]
					then
						# pandoc missing
						${repositorypath}/Markdown/markdown2.py mytext.md > mytext.html
						
					else
						# pandoc exists 
						pandoc -f markdown -o mytext.html mytext.md
						pandoc -f markdown -o standalone.html -s mytext.md
						
						#get css generated by pandoc and add as scoped attribute (HTML5)
						pandocstyle=`sed -n '/<style/,/style>/p' standalone.html`
					fi
					
					markdowntext=$(cat mytext.html)
					contentline="${contentline}\n<div class=\"markdown-body\">${pandocstyle} ${markdowntext}</div>\n"
					
				else	# If not markdown, print verbatim (with exception of few html tags)
				
					## allow some html formatting tags
					text=${text//==lt==strong==gt==/<strong>}  # search for strong tags
					text=${text//==lt====slash==strong==gt==/<\/strong>}  # search for strong tags
					text=${text//==lt==em==gt==/<em>}  # search for strong tags
					text=${text//==lt====slash==em==gt==/<\/em>}  # search for strong tags
					
					text=${text//==lt==b==gt==/<strong>}  # search for strong tags
					text=${text//==lt====slash==b==gt==/<\/strong>}  # search for strong tags
					text=${text//==lt==i==gt==/<em>}  # search for strong tags
					text=${text//==lt====slash==i==gt==/<\/em>}  # search for strong tags
					
					text=${text//==lt==br==gt==/<br\/>}  # search for strong tags
					text=${text//==lt====br==slash==gt==/<br\/>}  # search for strong tags
					text=${text//==lt==h1==gt==/<h1>}  # search for h1-h6 tags
					text=${text//==lt==h2==gt==/<h2>}  # search for h1-h6 tags
					text=${text//==lt==h3==gt==/<h3>}  # search for h1-h6 tags
					text=${text//==lt==h4==gt==/<h4>}  # search for h1-h6 tags
					text=${text//==lt==h5==gt==/<h5>}  # search for h1-h6 tags
					text=${text//==lt==h6==gt==/<h6>}  # search for h1-h6 tags
					text=${text//==lt====slash==h1==gt==/<\/h1>}  # search for h1-h6 closing tags
					text=${text//==lt====slash==h2==gt==/<\/h2>}  # search for h1-h6 closing tags
					text=${text//==lt====slash==h3==gt==/<\/h3>}  # search for h1-h6 closing tags
					text=${text//==lt====slash==h4==gt==/<\/h4>}  # search for h1-h6 closing tags
					text=${text//==lt====slash==h5==gt==/<\/h5>}  # search for h1-h6 closing tags
					text=${text//==lt====slaxh==h6==gt==/<\/h6>}  # search for h1-h6 closing tags
					
					## display everything else verbatim
					text=${text//==space==/ }
					text=${text//==colon==/:}
					text=${text//==comma==/,}
					text=${text//==slash==/\/}
					text=${text//==lt==/&lt;}
					text=${text//==gt==/&gt;}
					text=${text//==apos==/&apos;}
					text=${text//==quote==/&quot;}
					text=${text//&&/&amp;}
					text=${text//\\n/<br/>}
					text=${text//\\t/&emsp;}
					text=${text//\&r\&n/<br/>}
					text=${text//\&r/<br/>}
					text=${text//\&n/<br/>}
					text=${text//\&c/:}
					text=${text//==backtick==/&#96;}
					text=${text//==dollar==/$}
					text=${text//==bar==/|}
					text=${text//==braceopen==/(}
					text=${text//==braceclose==/)}
					text=${text//==cbraceopen==/{}
					text=${text//==cbraceclose==/&#125;}
					contentline="${contentline}\n${text}\n"
				fi
				
				
			fi
			
			##
			##  Text File
			##	
			if [ ${myarr[1]} == "textfile" ]
			then
				tfile=${myarr[2]}
				md=${myarr[4]}
				fname=`basename ${tfile}`
				fname=${fname%.*}
				fname="${fname}.txt"
				cp ${tfile} "${galaxypath}/${fname}"
				
				#estimate height for iframe based on number oflines in the file
				numlines=`wc -l ${tfile} | cut -d" " -f1`
				minheight=$[$numlines*17]
				
				# if markdown, convert to html
				if [ $md == "Y" ]
				then
				
					if [ -z `type -p pandoc` ]
					then
						# pandoc missing 
						${repositorypath}/Markdown/markdown2.py ${tfile} > mytext.html
						
					else
						# pandoc exists 
						pandoc -o mytext.html ${tfile}
						pandoc -o standalone.html -s ${tfile}
						
						# get css generated by pandoc and add as scoped attribute (HTML5)
						pandocstyle=`sed -n '/<style/,/style>/p' standalone.html`
						
					fi
					
					markdowntext=$(cat mytext.html)
					contentline="${contentline}\n<div class=\"markdown-body\">${pandocstyle} ${markdowntext}</div>\n"
				else				
					contentline="${contentline}\n<iframe class=\"invisibleframe\" src=\"${fname}\" width=\"100%\" height=\"$minheight\"> </iframe>\n"
				fi
			fi
			
			##
			##  Image
			##	
			if [ ${myarr[1]} == "image" ]
			
			then
				imgcount=$[$imgcount+1]
				#restore file suffix for html
				ftype=`file ${myarr[2]}`
				zoomlevel=${myarr[4]}
				zoomenable=${myarr[5]}
				align=${myarr[6]}
				typestring=""
				#####echo "zoomenable:${zoomenable}, align:${align}"
				if [[ $ftype == *JPEG* ]]
				then
					suffix=".jpg"
				fi
				if [[ $ftype == *SVG* ]]
				then
					suffix=".svg"
				fi
				if [[ $ftype == *PNG* ]]
				then
					suffix=".png"
				fi
				if [[ $ftype == *TIFF* ]]
				then
					suffix=".tiff"
					typestring="type=\"image/tiff\""
				fi
				
				image=`basename ${myarr[2]}`
				image=${image%.dat}
				image="${image}${suffix}"
				cp ${myarr[2]} ${galaxypath}/${image}
				
				if [[ ${align} == "none" ]]
				then
					alignstring=""
					alignstring2=""
				else 
					alignstring="<div float=\"${align}\">"
					alignstring2="</div>"
					
					alignstring="align=\"${align}\""
					alignstring2=""
				fi
				
				
				if [[ ${zoomlevel} -eq 0 ]]
				then
					widthstring=""
				else
					widthstring="width=\"${zoomlevel}\""
				fi
				
				if [[ ${zoomlevel} -eq 0 || ${zoomenable} == "N" ]]
				then
					contentline="${contentline}<span id=\"img${imgcount}\"> <img src=\"${image}\" ${alignstring} ${widthstring} alt=\"loading image..\"/></span>"
				else				
					contentline="${contentline}<span class=\"zoomme\" id=\"img${imgcount}\"> <img src=\"${image}\" ${alignstring} ${widthstring} alt=\"loading image..\"/></span>"
				fi
				
			fi
			
			##
			##  Table
			##	
			if [ ${myarr[1]} == "table" ]
			then
				
				maxlines=50000
				tsvfile_orig=${myarr[2]}
				tsvfile="tablehead.tsv"
				fname=`basename ${tsvfile_orig}`
				fname=${fname%.*}
				fancy=${myarr[4]}
				makelinks=${myarr[5]}
				iframeid="iframe"$iframecount
				#echo "\nmakelinks: $makelinks fancy: $fancy <br>"
				
				#TODO client side database for large files. For now only display first section of file and add download link
				numlines=`wc -l ${tsvfile_orig} |cut -d" " -f1`
								
				head -${maxlines} ${tsvfile_orig} > tsvtmpfile
				
				#remove any empty or header lines (lines starting with #, unless vcf file, then keep #CHROM line)
				awk 'BEGIN{
					FS="\t"
					OFS="\t"
				}{
					if((index($0,"#")==1 && index($0,"#CHROM")!=1) || $0==""){ 
						headerlines++
					}
					else print $0
						
				}END{}' tsvtmpfile > ${tsvfile}
				
				if [[ $makelinks == "Y" ]]
				then
					col=${myarr[6]}
					prefix=${myarr[7]}
					suffix=${myarr[8]}
					urlitems=${myarr[9]}
					minw=${myarr[10]}
					minh=${myarr[11]}
					suffix=${suffix/emptycol/}
					suffix=${suffix/==quote==/&}
					prefix=${prefix/emptycol/}
					prefix=${prefix/==quote==/&}
					prefix=${prefix/==colon==/:}
					
					# unpack archive of files to link to if present
					if [[ ${urlitems} != None ]]
					then
						oldfname=$fname
						decompressArchive ${urlitems}
						prefix=archive_${fname}/${prefix}
						fname=$oldfname
					fi
					
					
					#edit the table to include links
					awk 'BEGIN{
						FS="\t"
						OFS="\t"
						url="'"$prefix"'"
						url2="'"$suffix"'"
						iframeid="'"$iframeid"'"
						prefix="<a href=\42"
						suffix="\42 onclick=\42resizeIframe("iframeid")\42>"
						col="'"$col"'"
						end="</a>"
					}{
						if(FNR==1)
							print $0
					else{
							$col=prefix""url""$col""url2""suffix""$col""end
							print $0
						}
					}END{}' ${tsvfile} > ${tsvfile}2
				
				else
					minw=${myarr[6]}
					minh=${myarr[7]}
					cp ${tsvfile} ${tsvfile}2
				fi
				
				iframecount=$[$iframecount+1]
				if [ $fancy == "Y" ]
				then
					perl ${repositorypath}/tsv2html.pl < ${tsvfile}2 > ${galaxypath}/htmltable_${fname}.html
					contentline="${contentline}\n<iframe class=\"invisibleframe fancyiframe\" id=\"$iframeid\" src=\"htmltable_${fname}.html\" width=\"100%\" style=\"height: 350px; min-height: ${minh}px !important; overflow-y: hidden; overflow-x: scroll\" ></iframe>"
					iframecount=$[$iframecount+1]
				else
					perl ${repositorypath}/tsv2html_simple.pl < ${tsvfile}2 > ${galaxypath}/htmltable_${fname}.html
					contentline="${contentline}\n<iframe class=\"unfancyiframe invisibleframe\" id=\"$iframeid\" src=\"htmltable_${fname}.html\" scrolling=\"no\" style=\"min-width: ${minw}px; min-height: ${minh}px !important; max-width: 100%; vertical-align: top;\" onload=\"resizeIframe(this)\"></iframe>"
					iframecount=$[$iframecount+1]
				fi
				
				if [[ $numlines -gt ${maxlines} ]]
				then
					tablename=`basename ${tsvfile_orig}`
					cp ${tsvfile_orig} ${galaxypath}/$tablename
					contentline="${contentline}<br/>\nLarge tables will be supported soon. The first ${maxlines} lines are shown here, and you can download the full file <a href=\"${tablename}\">here</a>."					
				fi
			fi
			
			##
			##  PDF
			##	
			if [[ ${myarr[1]} == "pdf" ]]
			then
				pdffile=${myarr[2]}
				fname=`basename ${pdffile}`
				fname=${fname%.dat}
				pdfname="${fname}.pdf"
				cp ${pdffile} "${galaxypath}/${pdfname}"
				
				width=1000
				height=800
				echo -e "<html><body><object data=\"${pdfname}\" type=\"application/pdf\" width=\"$width\"  height=\"$height\"><embed src=\"${pdfname}\" type=\"application/pdf\" /><p>It appears you have no PDF plugin for your browser. No biggie... you can <a href=\"${pdfname}\">click here to	download the PDF file.</a></p></object></body></html>" > "${galaxypath}/${fname}.html"
				width=$[$width+10]
				height=$[$height+10]
				contentline="${contentline}\n<iframe src=\"${fname}.html\" width=\"${width}\"  height=\"${height}\"></iframe>\n"
				
			fi
			
			##
			##  HTML
			##
			if [[ ${myarr[1]} == "htmlfile" ]]
			then
				htmlfile=${myarr[2]}
				height=${myarr[4]}
				fname=`basename ${htmlfile}`
				fname=${fname%.dat}
				htmlname="${fname}.html"
				cp ${htmlfile} "${galaxypath}/${htmlname}"
				
				apiid=${myarr[5]}
				isireport=${myarr[6]}
				localhost=${myarr[7]}
				proxy=${myarr[8]}
				localhost=${localhost//==colon==/:}
				localhost=${localhost//==fslash==/\/}
				if [[ ${isireport} == "Y" ]]
				then
					#cp ${localhost}/datasets/${apiid}/* "${galaxypath}/tst"
					htmlname="/${proxy}/datasets/${apiid}/display/"
				fi
				
				contentline="${contentline}\n<iframe  class=\"invisibleframe\" src=\"${htmlname}\" width=\"100%\" height=\"${height}px\"></iframe>\n"
			fi
			
			
			if [[ ${myarr[1]} == "htmlpage" ]]
			then
				url=${myarr[2]}
				url=${url//==colon==/:}
				url=${url//==fslash==//}
				height=${myarr[4]}
				contentline="${contentline}\n<iframe class=\"invisibleframe\" src=\"${url}\" width=\"100%\" height=\"${height}px\"></iframe>\n"
			fi
			
			##
			##  Web Link
			##	
			if [ ${myarr[1]} == "weblink" ]
			then
				url=${myarr[2]}
				linktext=${myarr[4]}				
				
				echo -n "$url" > tmpfileb64
				url=`base64 -d tmpfileb64`
				
				echo -n "$linktext" > tmpfileb64
				linktext=`base64 -d tmpfileb64`
				
				if [[ -z $linktext ]]
				then
					linktext=$url
				fi
				contentline="${contentline}<a href=\"${url}\" target=\"_blank\">${linktext}</a>"
			fi
			

			##
			##  Genome Browser
			##	
			if [ ${myarr[1]} == "genomebrowser" ]
			then
				
				# parse inputs
				
				apiid=${myarr[4]}
				servername=${myarr[5]}
				buildver=${myarr[2]}
				
				
				region=${myarr[6]}
				
				
				echo -n "$region" > tmpfileb64
				region=`base64 -d tmpfileb64`
				
				
				initialchrom=${region%:*}
				initialrange=${region#*:}
				
				initialstart=${initialrange%-*}
				initialend=${initialrange#*-}
				
				
				#TODO 
				ftype="vcf"
				
				servername=${servername/==colon==/:}
				
				## parse and prepare all tracks
				gbcount=$[$gbcount+1]
				gbfilelist=${tracklist}
				userTracks=""
				#IFS=',' read -a gbfilearray <<< ${gbfilelist}
				gbfilearray=(${gbfilelist//,/ })
				for gbfile in "${gbfilearray[@]}"
				do
					# gbfile is in format "browsernum:file"
					#IFS=':' read -a gbfileinfo <<< ${gbfile}
					gbfileinfo=(${gbfile//:/ })
					if [[ ${gbfileinfo[0]} == $gbcount ]]
					then
					
						ftype=${gbfileinfo[3]}
						
						gbfilename=${gbfileinfo[1]}
						gbfilelabel=${gbfileinfo[2]}
						gbfilelabel=${gbfilelabel//==space==/ }
						gbfilelabel=${gbfilelabel//==bopen==/(}
						gbfilelabel=${gbfilelabel//==bclose==/)}
						fname=`basename ${gbfilename}`	
						fname=${fname%.dat}
						
						if [[ $ftype == "vcftabix" ]]
						then
							newgbfilename="${fname}.vcf"
							
							
							cp ${gbfilename} "${galaxypath}/${newgbfilename}"
							bgzip "${galaxypath}/${newgbfilename}"
							tabix -f -p vcf "${galaxypath}/${newgbfilename}.gz"
							
							userTracks="${userTracks},
								{name:                 '${gbfilelabel}',
								uri:                  '${servername}/datasets/${apiid}/display/${newgbfilename}.gz',
								tier_type:            'tabix',
								payload:              'vcf'}
							"
						fi
						
						if [[ $ftype == "vcfmemstore" ]]
						then
							newgbfilename="${fname}.vcf"
							
							
							cp ${gbfilename} "${galaxypath}/${newgbfilename}"
							#bgzip "${galaxypath}/${newgbfilename}"
							#tabix -p vcf "${galaxypath}/${newgbfilename}.gz"
							
							userTracks="${userTracks},
								{name:                 '${gbfilelabel}',
								uri:                  '${servername}/datasets/${apiid}/display/${newgbfilename}',
								tier_type:            'memstore',
								payload:              'vcf'}
							"
						fi
						
						if [[ $ftype == "bam" ]]
						then
							newgbfilename="${fname}.bam"
							
							# link to bam instead of copying
							ln -s ${gbfilename} "${galaxypath}/${newgbfilename}"
							samtools index "${galaxypath}/${newgbfilename}"
							
							userTracks="${userTracks},
								{name:                 '${gbfilelabel}',
								 bamURI:                  '${servername}/datasets/${apiid}/display/${newgbfilename}'}
							"
						
						fi
						
						if [[ $ftype == "bedtabix" ]]
						then
							newgbfilename="${fname}.bed"
							
							cp ${gbfilename} "${galaxypath}/${newgbfilename}"
							bgzip "${galaxypath}/${newgbfilename}"
							tabix -f -p bed "${galaxypath}/${newgbfilename}.gz"
							
							userTracks="${userTracks},
								{name:                 '${gbfilelabel}',
								uri:                  '${servername}/datasets/${apiid}/display/${newgbfilename}.gz',
								tier_type:            'tabix',
								payload:              'bed'}
							"
						
						fi
						
						if [[ $ftype == "bedmemstore" ]]
						then
							newgbfilename="${fname}.bed"
							
							cp ${gbfilename} "${galaxypath}/${newgbfilename}"
							#bgzip "${galaxypath}/${newgbfilename}"
							#tabix -p bed "${galaxypath}/${newgbfilename}.gz"
							
							userTracks="${userTracks},
								{name:                 '${gbfilelabel}',
								uri:                  '${servername}/datasets/${apiid}/display/${newgbfilename}',
								tier_type:            'memstore',
								payload:              'bed'}
							"
						
						fi
					fi
				done
				
				
				
				if [ ${buildver} == "hg18" ]
				then
					coordSystem="coordSystem: {
							speciesName: 'Human',
							taxon: 9606,
							auth: 'NCBI',
							version: '36',
							ucscName: 'hg18'
							},"

					chains="chains: {
								hg19ToHg18: new Chainset('https://www.biodalliance.org/das/hg19ToHg18/', 'GRCh37', 'NCBI36',
									{
										speciesName: 'Human',
										taxon: 9606,
										auth: 'GRCh',
										version: 37
									})
								},"

					genesTrack="{name:                'Genes',
								desc:                 'Gene structures from Ensembl 54',
								uri:                  'https://www.biodalliance.org/das/hsa_54_36p/',
								collapseSuperGroups:  true,
								provides_karyotype:   true,
								provides_search:      true,
								provides_entrypoints: true,
								maxbins:              false}, "

					repeatsTrack="{name:                'Repeats',
									desc:                 'Repeat annotation from Ensembl 59', 
									bwgURI:               'https://www.biodalliance.org/datasets/repeats.bb',
									stylesheet_uri:       'https://www.biodalliance.org/stylesheets/bb-repeats.xml'}"


				# default is hg19
				else
					coordSystem="coordSystem: {
							speciesName: 'Human',
							taxon: 9606,
							auth: 'NCBI',
							version: '37',
							ucscName: 'hg19'
							},"

					chains=""

					genesTrack="{name:                'Genes',
								desc:                 'Gene structures from GENCODE 19',
								bwgURI:               'https://www.biodalliance.org/datasets/gencode.bb',
								stylesheet_uri:       'https://www.biodalliance.org/stylesheets/gencode.xml',
								collapseSuperGroups:   true,
								trixURI:              'https://www.biodalliance.org/datasets/geneIndex.ix'},"

					repeatsTrack="{name:                'Repeats',
									desc:                 'Repeat annotation from Ensembl 59', 
									bwgURI:               'https://www.biodalliance.org/datasets/repeats.bb',
									stylesheet_uri:       'https://www.biodalliance.org/stylesheets/bb-repeats.xml'},"
									
				fi
				
				contentline="${contentline}
<script language=\"javascript\" src=\"https://www.biodalliance.org/release-0.13/dalliance-compiled.js\"></script>
<script language=\"javascript\">
  new Browser({
    chr:          '$initialchrom',
    viewStart:    $initialstart,
    viewEnd:      $initialend,
    cookieKey:    'human',
    pageName:     'svgHolder${gbcount}',
    ${coordSystem}

	${chains}
    sources:     [{name:                 'Genome',
                   twoBitURI:            'https://www.biodalliance.org/datasets/${buildver}.2bit',
                   tier_type:            'sequence'},
                  ${genesTrack},
                  ${repeatsTrack},
                  {name:                 'Conservation',
                   desc:                 'Conservation', 
                   bwgURI:               'https://www.biodalliance.org/datasets/phastCons46way.bw',
                   noDownsample:          true} 
                  ${userTracks}
                 ],



	
    browserLinks: {
      Ensembl: 'http://www.ensembl.org/Homo_sapiens/Location/View?r=${chr}:${start}-${end}',
      UCSC: 'http://genome.ucsc.edu/cgi-bin/hgTracks?db=${buildver}&position=chr${chr}:${start}-${end}',
      Sequence: 'http://www.derkholm.net:8080/das/${buildver}comp/sequence?segment=${chr}:${start},${end}'
    }

  });
</script>

<div id=\"svgHolder${gbcount}\"></div>
"
			fi

			##
			##  Link to Dataset
			##	
			if [ ${myarr[1]} == "link" ]
			then
				linkfile=${myarr[2]}
				apiid=${myarr[4]}
				isireport=${myarr[5]}
				linkfilename=`basename ${linkfile}`
				linktext=${myarr[6]}
				
				localhost=${myarr[7]}
				proxy=${myarr[8]}
				localhost=${localhost//==colon==/:}
				localhost=${localhost//==fslash==/\/}
				
				#check for some basic filetypes
				ftype=`file $linkfile`
				if [[ $ftype == *HTML* ]]
				then
					linkfilename=${linkfilename%.dat}
					linkfilename=${linkfilename}.html
				fi
				if [[ $ftype == *PNG* ]]
				then
					linkfilename=${linkfilename%.dat}
					linkfilename=${linkfilename}.png
				fi
				if [[ $ftype == *SVG* ]]
				then
					linkfilename=${linkfilename%.dat}
					linkfilename=${linkfilename}.svg
				fi
				if [[ $ftype == *JPEG* ]]
				then
					linkfilename=${linkfilename%.dat}
					linkfilename=${linkfilename}.jpg
				fi
				
				
				if [[ ${isireport} == "Y" ]]
				then					
					linkfilename="/${proxy}/datasets/${apiid}/display/"
				else
					cp ${linkfile} "${galaxypath}/${linkfilename}"
				fi
			
				contentline="${contentline}<a href=\"${linkfilename}\">${linktext}</a>"
			fi
			
			##
			##  Links to Archive Contents
			##	
			if [[ ${myarr[1]} == "links" ]]
			then			
				archive=${myarr[2]}
				decompressArchive $archive

				# add links to webpage
				# separate line for each folder, files within folder on same line
				for linkfile in `ls ${galaxypath}/archive_${fname}/ |sort -V`
				do
					#echo  "<br/> ->making link to file: $linkfile "
					if [ -d ${galaxypath}/archive_${fname}/$linkfile ]  # if directory, add break, and list all contained files, max level 1 deep
					then
						#echo  "<br/> ->is directory, entering: $linkfile "
						#ls ${galaxypath}/archive_${fname}/$linkfile
						contentline="${contentline}"
						for linkfile2 in `ls ${galaxypath}/archive_${fname}/$linkfile | sort -V`
						do
							#echo  "<br/> ->making link to file: ${galaxypath}/archive_${fname}/$linkfile2"
							if [ -f ${galaxypath}/archive_${fname}/$linkfile/$linkfile2 ]  # if directory, add break, and list all contained files, max level 1 deep
							then
								#echo  "<br/> ->is file, making link: $linkfile "
								label=`basename $linkfile2`
								label=${label%.*}
								contentline="${contentline}<a class=\"mylinks\" href=\"archive_${fname}/${linkfile}/${linkfile2}\">${label}</a>&nbsp;\n "
							fi
						done
					elif [ -f ${galaxypath}/archive_${fname}/$linkfile ]
					then
						label=`basename ${galaxypath}/archive_${fname}/$linkfile`
						label=${label%.*}
						contentline="${contentline}<a class=\"mylinks\" href=\"archive_${fname}/${linkfile}\">$label</a>&nbsp;\n"
					fi
				done
				
				
			fi
			
			if [[ ${myarr[3]} == "Y" ]]
			then
				contentline="${contentline}<br/>\n"
			fi		
		fi
	done
	
	echo "${contentline}"
}

##
## Create HTML content for iReport
##
createMainPage (){
	page=$1
	tabtitles=$2	# comma-separated list of tab titles
	tabitems=$3		# colon-sparated list of tabs specifications
	iframecount=1	# keep track of number of iFrames so that they can be referenced by ID
	minwidth=$4		# width of page
	gbtracks=$5		# genome browser track information
	
	echo "createMainPage: tabitems: $tabitems. tabtitles: $tabtitles. gbtracks: $gbtracks"
	# create correct number of tabs
	count=0
	
	tabtitles=${tabtitles/,/}
	tabtitles=${tabtitles//,/ }
	echo $tabtitles
	
	tabcount=0
	for tabt in $tabtitles
	do
		echo -n $tabt > tmpfileb64
		thistabtitle=`base64 -d tmpfileb64`
		newtabtitles+=" $thistabtitle"
		tabcount=$[tabcount+1]
	done
	
	echo $newtabtitles
	
	tabslist="<ul>\n"
	mytabs=""
	
	for title in $newtabtitles
	do
		# Create list of tabs		
		count=$[count+1]
		title2=${title//==space==/ }
		title2=${title2//==dollar==/$}
		title2=${title2//==colon==/}
		tabslist="${tabslist} <li><a href=\"#tabs-${count}\">${title2}</a></li>\n"
		
		# Create tabs with content
		tabcontent=$(makeTabContent $title "$tabitems" "$gbtracks")
		mytabs="${mytabs}\n<div id=\"tabs-${count}\">\n"
		mytabs="${mytabs}${tabcontent}"
		mytabs="${mytabs}\n</div>\n"
	done
	tabslist="${tabslist}</ul>"
	
	## Output the webpage
	echo -e "<!doctype html>
 <head>
  <meta charset=\"utf-8\">
  <title>iReport</title>
  <link rel=\"stylesheet\" href=\"jquery-ui.css\">
  <link rel=\"stylesheet\" href=\"ireport_css.css\">
  <link rel=\"stylesheet\" href=\"md.css\">
  <script type=\"text/javascript\" src=\"jquery-1.10.2.js\"></script>
  <script type=\"text/javascript\" src=\"jquery-ui.js\"></script>	
  <script type=\"text/javascript\" src=\"iframe-resizer/src/iframeResizer.js\"></script> 
  <script type=\"text/javascript\" src=\"jquery.zoom.js\"></script>
  <script type=\"text/javascript\" src=\"ireport_jquery.js\"></script>
  <script type=\"text/javascript\" src=\"ireport_javascript.js\"></script>
 </head>
 <body>
  <div id=\"tabs\" style=\"display:inline-block; min-height:100%; min-width:${minwidth}px\">
  $tabslist

  $mytabs
  </div>
 </body>
</html>" > $page
}
